# 자료 구조
  Data Structure는 효율적으로 데이터를 CRUD할 수 있는 데이터 집합을 말합니다.


# 복잡도
복잡도는 시간 복잡도와 공간 복잡도로 나뉩니다.


# 시간 복잡도
 - 빅오 표기법 : 시간 복잡도란 '입력 크기에 대해 어떠한 알고리즘이 실행되는 데 걸리는 시간'입니다. 주요 로직의 반복 횟수를 중심으로 측정되며, 보통 빅오 표기법으로 나타냅니다.

 빅오 표기법이란 입력 범위 n을 기준으로 해서 로직인 몇 번 반복되는지 나타내는 것인데, 앞서 말한 코드의 시간 복잡도를 빅오 표기법으로 나타내면
O(n²)이 됩니다.

 - 시간 복잡도의 존재 이유
 시간 복잡도는 효율적인 코드로 개선하는 데 쓰이는 척도가 됩니다.


# 공간 복잡도
공간 복잡도는 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양을 말합니다. 정적 변수로 선언된 것 말고도 동적으로 재귀적인 함수로 인해 공간을 계속해서 필요로 할 경우도 포함합니다.


# 선형 자료 구조
선형 자료 구조란 요소가 일렬로 나열되어 잇는 자료 구조를 말합니다.


# 연결 리스트
연결 리스트는 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료 구조입니다. 삽입과 상제가 O(1)이 걸리며 탐색에는 O(n)걸립니다.


# 배열
Array는 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합입니다. 중복을 허용하고 순서가 있습니다. '정적 배열'을 기반으로 접근(참조)에 O(1)이 시간 복잡도를 가지며 랜덤 접근(Random Access)이 가능합니다. 삽입과 삭제에는 O(n)이 걸립니다.

따라 데이터 추가와 삭제를 많이 하는 것은 연결 리스트, 접근(참조)를 많이하는 것은 배열로 하는 것이 좋습니다.

 - 랜덤 접근과 순차적 접근
 직접 접근이라고 하는 랜덤 접근은 동일한 시간에 배열과 같은 수차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능입니다. 이는 데이터를 저장된 순서대로 검색해야 하는 순차적 접근과는 반대입니다.

 - 연결 리스트와 배열의 비교
 연결 리스트는 상자를 선으로 연결한 형태의 데이터 구조이며, 상자 안의 요소를 알기 위해서는 하나씩 상자 내부를 확인해봐야 합니다. [O(n)]

 배열은 상자를 순서대로 나열한 데이터 구조이며 몇 번째 상자인지만 알면 해당 상자의 요소를 꺼낼 수 있습니다. [O(1)]


# 벡터
Vector는 동적으로 요소를 할당할 수 있는 동적 배열입니다. 컴파일 시점에 개수를 모른다면 베거를 써야 한다. 중복을 허용하며 순서가 있고 랜덤 접근이 가능하다. 탐색과 맨뒤의 요소를 삭제, 삽입에 O(1), 맨 뒤가 아닌 요소를 삭제, 삽입에 O(n)의 시간 복잡도를 갖습니다.


# 스택
Stack은 LIFO(Last In First Out)의 성질을 가진 자료구조 입니다.
재귀적인 함수, 알고리즘에 사용되며 웹 브라우저 방문 기록 등에 쓰입니다.
삽입, 삭제에 O(1), 탐색에 O(n)이 걸립니다.


# 큐
Queue는 FIFO(First In First Out)의 성질을 가진 자료구조입니다.
CPU 작업을 기다리는 프로세스, 스레드 행렬 또는 네트워크 접속을 기다리는 행렬, 너비 우선 탐색, 캐시 등에 사용됩니다.
삽입, 삭제에 O(1), 탐색에 O(n)이 걸립니다.


# 비선형 자료 구조
비선형 자료 구조란 일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조를 말합니다.
일반적으로 트리나 그래프가 있습니다.


# 그래프
그래프는 정점과 간선으로 이루어진 자료 구조를 말합니다.

 - 정점과 간선 : 어떤 곳에서 어떤 곳으로 무언가를 통해 간다 할 때, '어떤 곳'은 정점(Vertex), '무언가'는 간선(Edge)가 됩니다.

 - 가중치 : 간선과 정점 사이에 드는 비용을 뜻합니다.


# 트리
트리 구조로 배열된 계층적 데이터의 집합으로 정점과 간선이 동일하게 존재합니다.

 - 트리의 구성 : 루트 노드, 내부 노드, 리프 노드 등으로 구성되어 있습니다.

 - 루트 노드 : 가장 위에 있는 노드, 보통 트리 문제가 나와 트리를 탐색할 때 루트 노드 중심을 탐색하면 문제가 쉽게 풀리는 경우가 많습니다.

 - 내부 노드 : 루트 노드와 리프 노드 사이에 있는 노드입니다.

 - 리프 노드 : 리프 노드는 자식 노드가 없는 노드입니다.


# 이진 트리
이진 트리는 자식의 노드 수가 두 개 이하인 트리를 의미합니다.

 - 정이진 트리 (Full Binary Tree) : 자식 노드가 0 또는 두 개인 이진 트리를 의미합니다.
 - 완전 이진 트리 (Complete Binary Tree) : 왼쪽에서 부터 채워진 이진 트리를 의미합니다.
 - 변질 이진 트리 (Degenerate Binary Tree) : 자식 노드가 하나밖에 없는 이진 트리를 의미합니다.
 - 포화 이진 트리 (Perfect Binary Tree) : 모든 노드가 꽉 차 있는 이진 트리를 의미합니다.
 - 균형 이진 트리 (Balanced Binary Tree) : 왼쪽과 오른쪽 노드의 높이 차이가 1이하인 이진 트리를 의미합니다. map, set을 구성하는 레드 블랙 트리는 균형 이진 트리 중 하나입니다.


# 이진 탐색 트리
BST는 노드의 오른쪽 하위 트리에는 '노드 값보다 큰 값'이 있는 노드만 포함되고, 왼쪽 하위 트리에는 '노드 값보다 작은 값'이 들어 있는 트리를 말합니다.
보통 요소를 찾을 때 O(logn)이 걸립니다. 최악의 경우 O(n).


# AVL 트리
Adelson-Velsky and Landis tree는 앞서 설명한 최악의 경우 선형적인 트리가 되는 것을 방지하고 스스로 균형을 잡는 이진 탐색 트리입니다.
두 자식 서브 트리의 높이는 항상 최대 1만큼 차이 난다는 특징이 있습니다.
탐색, 삽입, 삭제 모두 시간 복잡도가 O(logn)이며 삽입, 삭제를 할 때마다 균형을 맞추기 위해 트리 일부를 왼쪽 혹은 오른쪽으로 회전 시키며 균형을 잡는다.

 - 레드 블랙 트리
 레드 블랙 트리는 균형 이진 탐색 트리로 탐색, 삽입, 삭제 모두 시간 복잡도가 O(logn)을 갖습니다.
 각 노드는 빨간색 또는 검은색의 색상을 나타내는 추가 비트를 저장하며, 삽입, 삭제 중 트리가 균형을 유지하도록 하는 데 사용합니다.


# 힙
힙은 완전 이진 트리 기반의 자료 구조이며, 최소힙과 최대힙 두 가지가 있고 해당 힙에 따라 특정한 특징을 지킨 트리입니다.

 - 최대힙 : 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 커야 합니다. 또한 각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 합니다.
 - 최소힙 : 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 작아야 합니다. 또한 각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 합니다.

 - 최대힙의 삽입
 힙에 새로운 요소가 들어오면 우선 새로운 노드를 힙의 마지막 노드에 이어 삽입합니다.
 이 새로운 노드를 부모 노드들과의 크기를 비교하며 교환해서 힙의 성질을 만족시킵니다.

 - 최대힙의 삭제
 최대힙에서 최댓값은 루트 노드이므로 루트 노드가 삭제되고, 그 이후 마지막 노드와 루트 노드를 스왑하여 또 다시 스완 등의 과정을 거쳐 재구성 됩니다.


# 우선순위 큐
우선순위 큐는 우선순위 대기열이라고도 하며, 대기열에서 우선순위가 높은 요소가 우선 순위가 낮은 요소보다 먼저 제공되는 자료 구조입니다.
우선순위 큐는 힙 기반으로 구현됩니다.


# 맵
Map은 특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조입니다.
레드 블랙 트리 자료 구조를 기반으로 형성되고, 삽입하면 자동으로 정렬됩니다.

참고로 map은 해시 테이블을 구현할 때 쓰며 정렬을 보장하지 않는 unordered_map과 정렬을 보장하는 map 2가지가 있습니다.


# 셋
Set은 특정 순서에 따라 고유한 요소를 저장하는 컨테이너이며, 중보되는 요소는 없고 오직 Unique한 값만 저장하는 자료 구조입니다.


# 해시 테이블
해시 테이블은 무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블입니다.
삽입, 삭제, 탐색 시 평균적으로 O(1)의 시간 복잡도를 가지며 unordered_map으로 구현합니다.
